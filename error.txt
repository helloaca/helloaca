// contractService.ts - Complete Implementation

import { supabase } from '../config/supabase';
import { claude } from './claude';

interface ContractAnalysis {
  overallRiskLevel: 'High Risk Level' | 'Medium Risk' | 'Low Risk';
  keyFindings: Array<{
    title: string;
    description: string;
    severity: 'High' | 'Medium' | 'Low';
    category: 'risk' | 'opportunity' | 'obligation';
  }>;
  clauseAnalysis: Array<{
    title: string;
    content: string;
    analysis: string;
    riskLevel: 'high' | 'medium' | 'low' | 'none';
    issues: string[];
    suggestions: string[];
  }>;
  summary: string;
}

export class ContractService {
  /**
   * Comprehensive AI-powered contract analysis with automatic retry
   * This identifies ALL risks, missing clauses, and provides actionable suggestions
   */
  async analyzeContractWithAI(contractId: string, retryCount: number = 0): Promise<ContractAnalysis> {
    const MAX_RETRIES = 2;
    
    try {
      const contract = await this.getContract(contractId);
      
      if (!contract.extractedText) {
        throw new Error('Contract text not available for analysis');
      }

      console.log('üîç Starting comprehensive contract analysis...');
      console.log(`üìÑ Contract: ${contract.title}`);
      console.log(`üìù Text length: ${contract.extractedText.length} characters`);
      if (retryCount > 0) {
        console.log(`üîÑ Retry attempt ${retryCount}/${MAX_RETRIES}`);
      }

      // Build the analysis prompt (use concise version if retrying)
      const prompt = retryCount === 0 
        ? this.buildAnalysisPrompt(contract)
        : this.buildConciseAnalysisPrompt(contract);

      // Get AI analysis
      console.log('ü§ñ Sending to Claude AI...');
      const response = await claude.sendMessage(prompt);

      // Parse and validate response
      const analysis = this.parseAnalysisResponse(response);

      // Check if response was truncated
      if (this.isAnalysisTruncated(analysis)) {
        console.warn('‚ö†Ô∏è Analysis appears truncated');
        
        // Retry with more concise prompt
        if (retryCount < MAX_RETRIES) {
          console.log('üîÑ Retrying with more concise prompt...');
          return this.analyzeContractWithAI(contractId, retryCount + 1);
        } else {
          console.error('‚ùå Max retries reached, analysis still truncated');
          // Return what we have - it's better than nothing
        }
      }

      // Validate analysis quality
      this.validateAnalysis(analysis);

      // Save to database
      await this.saveAnalysis(contractId, analysis);

      console.log('‚úÖ Analysis complete and saved');
      return analysis;

    } catch (error) {
      console.error('‚ùå Analysis failed:', error);
      
      // If this was a parsing error and we haven't retried yet, try again
      if (error.message.includes('truncated') && retryCount < MAX_RETRIES) {
        console.log('üîÑ Retrying due to truncation...');
        return this.analyzeContractWithAI(contractId, retryCount + 1);
      }
      
      throw error;
    }
  }

  /**
   * Check if analysis was truncated/incomplete
   */
  private isAnalysisTruncated(analysis: ContractAnalysis): boolean {
    // Check for truncation indicators
    const hasTruncationFinding = analysis.keyFindings?.some(f => 
      f.title.includes('Truncated') || 
      f.title.includes('Incomplete') ||
      f.description.includes('cut off')
    );

    // Check if analysis is suspiciously short
    const hasVeryFewFindings = (analysis.keyFindings?.length || 0) < 3;
    const hasNoClauses = !analysis.clauseAnalysis || analysis.clauseAnalysis.length === 0;

    return hasTruncationFinding || (hasVeryFewFindings && hasNoClauses);
  }

  /**
   * Build concise analysis prompt for retry attempts
   */
  private buildConciseAnalysisPrompt(contract: any): string {
    return `You are a contract attorney. Analyze this contract and identify the TOP 5 most critical risks only.

CONTRACT:
${contract.extractedText}

Return ONLY this JSON (keep it SHORT):

{
  "overallRiskLevel": "High Risk Level" | "Medium Risk" | "Low Risk",
  "keyFindings": [
    {
      "title": "Brief risk title",
      "description": "1-2 sentence explanation of the risk and impact",
      "severity": "High" | "Medium" | "Low",
      "category": "risk"
    }
  ],
  "clauseAnalysis": [
    {
      "title": "Clause name",
      "content": "Original clause text",
      "analysis": "Brief 1-2 sentence analysis",
      "riskLevel": "high" | "medium" | "low",
      "issues": ["Issue 1", "Issue 2"],
      "suggestions": ["Improved clause text in 1-2 sentences"]
    }
  ],
  "summary": "2-3 sentence overall assessment"
}

CRITICAL RULES:
- Maximum 5 findings
- Maximum 3 clause analyses  
- Keep descriptions under 2 sentences
- Keep suggestions under 2 sentences
- ENSURE JSON IS COMPLETE with all brackets closed
- Return ONLY valid JSON, nothing else

Focus on: missing termination clause, vague payment terms, missing dispute resolution, undefined key terms, and missing liability limits.`;
  }

  /**
   * Build comprehensive analysis prompt
   */
  private buildAnalysisPrompt(contract: any): string {
    return `You are a senior contract attorney with 20+ years of experience reviewing business agreements. Your role is to conduct a thorough legal analysis and identify ALL potential risks, missing clauses, and problematic terms.

CRITICAL: Your response MUST be valid, complete JSON. Do not truncate or cut off mid-response.

CONTRACT INFORMATION:
Title: ${contract.title}
Type: ${contract.type || 'Business Agreement'}
Date Uploaded: ${contract.uploadDate}

FULL CONTRACT TEXT:
${contract.extractedText}

================================================================================
ANALYSIS REQUIREMENTS:
================================================================================

You must analyze this contract as if you're advising a client who is about to sign it. Identify EVERY potential problem, missing protection, and legal risk.

CRITICAL AREAS TO EXAMINE:

1. MISSING CLAUSES (Common in contracts):
   - Termination rights (how can parties exit?)
   - Duration/Term (when does it end?)
   - Dispute resolution (arbitration, mediation, litigation?)
   - Governing law (which jurisdiction applies?)
   - Amendment process (how to modify the agreement?)
   - Force majeure (what if external events prevent performance?)
   - Liability limitations (who's liable for what?)
   - Indemnification (who protects whom from claims?)
   - Intellectual property rights
   - Confidentiality scope and duration
   - Non-compete/Non-solicitation
   - Assignment rights (can parties transfer the agreement?)
   - Notice requirements (how to communicate officially?)
   - Severability (what if one clause is invalid?)
   - Entire agreement clause
   - Survival clause (what survives termination?)

2. VAGUE OR AMBIGUOUS TERMS:
   - Undefined payment schedules
   - Unclear deadlines
   - Subjective performance standards
   - Missing specific amounts, dates, or metrics
   - Terms like "reasonable", "prompt", "soon" without definition

3. ONE-SIDED PROVISIONS:
   - Terms that heavily favor one party
   - Unfair liability allocations
   - Unequal termination rights
   - Imbalanced obligations

4. RISKY CLAUSES:
   - Overly broad confidentiality
   - Automatic renewals without notice
   - Hidden fees or charges
   - Restrictive non-compete terms
   - Unlimited liability exposure

5. PAYMENT ISSUES:
   - No specific payment dates
   - Missing late payment penalties
   - Unclear refund policies
   - No expense reimbursement terms
   - Vague installment terms

================================================================================
OUTPUT FORMAT:
================================================================================

Return your analysis as a JSON object with this EXACT structure:

{
  "overallRiskLevel": "High Risk Level" | "Medium Risk" | "Low Risk",
  "keyFindings": [
    {
      "title": "Specific, clear title of the issue",
      "description": "Detailed explanation of WHY this is a problem and what could go wrong. Include real-world implications.",
      "severity": "High" | "Medium" | "Low",
      "category": "risk" | "opportunity" | "obligation"
    }
  ],
  "clauseAnalysis": [
    {
      "title": "Name of the clause or topic",
      "content": "Exact text from the contract (quote it directly)",
      "analysis": "Detailed explanation of what this means, why it's problematic, and potential consequences",
      "riskLevel": "high" | "medium" | "low" | "none",
      "issues": [
        "Specific issue #1",
        "Specific issue #2",
        "Specific issue #3"
      ],
      "suggestions": [
        "Complete replacement clause text that fixes ALL issues. Write it as if it's ready to copy-paste into a contract. Be specific with amounts, dates, procedures."
      ]
    }
  ],
  "summary": "Overall assessment of the contract - is it safe to sign? What are the biggest red flags?"
}

================================================================================
EXAMPLES OF WHAT TO INCLUDE:
================================================================================

EXAMPLE KEY FINDING:
{
  "title": "No Termination Clause",
  "description": "This agreement contains no provision allowing either party to terminate the relationship. This means you could be locked into this agreement indefinitely with no legal way to exit, even if circumstances change or the relationship becomes unworkable. Without termination rights, you lose negotiating leverage and could face breach of contract claims if you simply stop performing.",
  "severity": "High",
  "category": "risk"
}

EXAMPLE CLAUSE ANALYSIS:
{
  "title": "Payment Terms",
  "content": "Payments made weekly in cryptocurrency. May be paid in installments.",
  "analysis": "This payment clause is dangerously vague. It doesn't specify which day of the week payments are due, which cryptocurrency to use, the wallet address, or how long installments can extend. This ambiguity creates multiple problems: you have no recourse if payments are delayed, no way to prove breach if payments stop, and no clarity on when the debt is satisfied.",
  "riskLevel": "high",
  "issues": [
    "No specific payment day or date defined",
    "No cryptocurrency type specified (Bitcoin? Ethereum? Stablecoin?)",
    "No wallet address for payments",
    "Installment terms completely undefined - could stretch indefinitely",
    "No late payment penalties or interest",
    "No procedure if payment fails or is disputed"
  ],
  "suggestions": [
    "PAYMENT TERMS: The Cave shall pay Collab Manager via cryptocurrency transfer within seven (7) days of confirmed project funding as follows: (a) ONE THOUSAND US DOLLARS ($1,000) for projects securing funding under $2,000,000; (b) TWO THOUSAND US DOLLARS ($2,000) for projects securing funding over $2,000,000. Payments shall be made in USDC (USD Coin) to wallet address [SPECIFIC ADDRESS]. If paid in installments, payment schedule shall be: 50% within 7 days, remaining 50% within 14 days. Late payments shall incur 1.5% interest per month. All payments are non-refundable once services are rendered."
  ]
}

================================================================================
QUALITY STANDARDS:
================================================================================

1. Every keyFinding must identify a real, specific problem (not generic observations)
2. Every suggestion must be complete, copy-paste-ready contract language
3. Include at least 5-10 key findings for any contract (there are always issues to find)
4. Be specific: instead of "payment terms unclear", say "No payment deadline specified, creating enforcement problems"
5. Think like an attorney protecting a client: what could go wrong? What's missing?
6. For missing clauses, explain what protection the client loses by not having them

================================================================================
IMPORTANT REMINDERS:
================================================================================

- If you see vague language like "reasonable time", "promptly", "good faith" - flag it as ambiguous
- If a clause is one-sided, explain how it could be abused
- If something is missing that's standard in this type of agreement, note it as a gap
- Every risk you identify in your analysis MUST appear in keyFindings
- Every problematic clause MUST appear in clauseAnalysis with specific fixes
- Your suggestions should be better than the original - add specificity, protection, and clarity

================================================================================
IMPORTANT JSON FORMATTING RULES:
================================================================================

1. Keep descriptions concise but informative (2-3 sentences max per finding)
2. Limit to 8-10 key findings maximum
3. Limit to 5-6 clause analyses maximum
4. Each suggestion should be 2-3 sentences of contract language
5. ENSURE THE JSON IS COMPLETE - close all brackets and braces
6. Test your JSON is valid before returning it

Return ONLY the JSON object. No additional commentary outside the JSON.`;
  }

  /**
   * Parse and extract JSON from Claude's response
   */
  private parseAnalysisResponse(response: string): ContractAnalysis {
    try {
      console.log('üîç Parsing Claude response...');
      console.log('üìù Response length:', response.length);
      
      let jsonString = response.trim();

      // Remove markdown code blocks if present
      // Try multiple patterns as Claude formats responses differently
      
      // Pattern 1: ```json\n...\n```
      let match = jsonString.match(/```json\s*([\s\S]*?)\s*```/);
      
      // Pattern 2: ```\n...\n```
      if (!match) {
        match = jsonString.match(/```\s*([\s\S]*?)\s*```/);
      }
      
      // Pattern 3: Look for the opening { and closing } of JSON
      if (!match) {
        const startIndex = jsonString.indexOf('{');
        const lastIndex = jsonString.lastIndexOf('}');
        if (startIndex !== -1 && lastIndex !== -1 && lastIndex > startIndex) {
          jsonString = jsonString.substring(startIndex, lastIndex + 1);
        }
      } else {
        jsonString = match[1].trim();
      }

      console.log('üìÑ Extracted JSON string length:', jsonString.length);
      console.log('üìÑ First 100 chars:', jsonString.substring(0, 100));
      console.log('üìÑ Last 100 chars:', jsonString.substring(jsonString.length - 100));

      // Check if JSON seems complete (ends with })
      if (!jsonString.trim().endsWith('}')) {
        console.warn('‚ö†Ô∏è JSON appears incomplete - does not end with }');
        // Try to find the last complete object
        const lastBrace = jsonString.lastIndexOf('}');
        if (lastBrace > 0) {
          console.log('üîß Attempting to use JSON up to last complete brace');
          jsonString = jsonString.substring(0, lastBrace + 1);
        }
      }

      // Parse JSON
      const analysis = JSON.parse(jsonString) as ContractAnalysis;

      console.log('‚úÖ JSON parsed successfully');
      console.log(`   üìä Risk Level: ${analysis.overallRiskLevel}`);
      console.log(`   üîç Key Findings: ${analysis.keyFindings?.length || 0}`);
      console.log(`   üìã Clauses Analyzed: ${analysis.clauseAnalysis?.length || 0}`);

      return analysis;

    } catch (error) {
      console.error('‚ùå Failed to parse analysis response');
      console.error('Error:', error);
      console.error('Response length:', response.length);
      console.error('Response preview (first 500 chars):', response.substring(0, 500));
      console.error('Response preview (last 500 chars):', response.substring(response.length - 500));
      
      // Try aggressive repair - attempt to close incomplete JSON
      try {
        console.log('üîÑ Attempting aggressive JSON repair...');
        let repairedJson = response;
        
        // Extract just the JSON part
        const startIndex = repairedJson.indexOf('{');
        const lastBraceIndex = repairedJson.lastIndexOf('}');
        
        if (startIndex !== -1 && lastBraceIndex !== -1) {
          repairedJson = repairedJson.substring(startIndex, lastBraceIndex + 1);
          
          // Count opening and closing brackets
          const openBraces = (repairedJson.match(/{/g) || []).length;
          const closeBraces = (repairedJson.match(/}/g) || []).length;
          const openBrackets = (repairedJson.match(/\[/g) || []).length;
          const closeBrackets = (repairedJson.match(/\]/g) || []).length;
          
          console.log(`üîç Braces: ${openBraces} open, ${closeBraces} close`);
          console.log(`üîç Brackets: ${openBrackets} open, ${closeBrackets} close`);
          
          // Try to close any unclosed arrays or objects
          if (openBrackets > closeBrackets) {
            // Remove incomplete array element if it exists
            const lastComma = repairedJson.lastIndexOf(',');
            if (lastComma > repairedJson.lastIndexOf(']')) {
              repairedJson = repairedJson.substring(0, lastComma);
            }
            repairedJson += ']'.repeat(openBrackets - closeBrackets);
          }
          
          if (openBraces > closeBraces) {
            repairedJson += '}'.repeat(openBraces - closeBraces);
          }
          
          console.log('üîß Repaired JSON (last 200 chars):', repairedJson.substring(repairedJson.length - 200));
          
          const analysis = JSON.parse(repairedJson) as ContractAnalysis;
          console.log('‚úÖ Repaired JSON parsed successfully!');
          console.log(`   üìä Risk Level: ${analysis.overallRiskLevel}`);
          console.log(`   üîç Key Findings: ${analysis.keyFindings?.length || 0}`);
          console.log(`   üìã Clauses Analyzed: ${analysis.clauseAnalysis?.length || 0}`);
          
          return analysis;
        }
      } catch (repairError) {
        console.error('‚ùå JSON repair also failed:', repairError);
      }
      
      throw new Error('Failed to parse AI analysis. The response was incomplete or invalid JSON. Please try again.');
    }
  }

  /**
   * Validate that the analysis is comprehensive and useful
   */
  private validateAnalysis(analysis: ContractAnalysis): void {
    const issues: string[] = [];

    // Check overall risk level
    if (!analysis.overallRiskLevel) {
      issues.push('Missing overall risk level');
    }

    // Check key findings
    if (!analysis.keyFindings || analysis.keyFindings.length === 0) {
      issues.push('No key findings identified - analysis is incomplete');
    } else if (analysis.keyFindings.length < 3) {
      console.warn('‚ö†Ô∏è Only found', analysis.keyFindings.length, 'findings - this seems low');
    }

    // Check for placeholder/generic content
    const hasPlaceholder = analysis.keyFindings?.some(
      finding => 
        finding.title === 'Analysis incomplete' ||
        finding.description.includes('Perform manual review') ||
        finding.description.length < 50 // Too short to be useful
    );

    if (hasPlaceholder) {
      issues.push('Analysis contains placeholder content - not a real analysis');
    }

    // Check clause analysis
    if (!analysis.clauseAnalysis || analysis.clauseAnalysis.length === 0) {
      console.warn('‚ö†Ô∏è No clause analysis provided');
    } else {
      // Check if clauses have actual suggestions
      const hasRealSuggestions = analysis.clauseAnalysis.some(
        clause => clause.suggestions && clause.suggestions.length > 0
      );

      if (!hasRealSuggestions) {
        console.warn('‚ö†Ô∏è Clauses analyzed but no suggestions provided');
      }
    }

    // If there are critical issues, throw error
    if (issues.length > 0) {
      console.error('‚ùå Analysis validation failed:');
      issues.forEach(issue => console.error('   -', issue));
      throw new Error(`Analysis validation failed: ${issues.join(', ')}`);
    }

    console.log('‚úÖ Analysis validation passed');
  }

  /**
   * Save analysis to database
   */
  async saveAnalysis(contractId: string, analysis: ContractAnalysis): Promise<void> {
    try {
      const { error } = await supabase
        .from('contracts')
        .update({
          analysis: analysis,
          risk_level: analysis.overallRiskLevel,
          analyzed_at: new Date().toISOString(),
          status: 'analyzed'
        })
        .eq('id', contractId);

      if (error) throw error;
      
      console.log('üíæ Analysis saved to database');
    } catch (error) {
      console.error('‚ùå Error saving analysis:', error);
      throw error;
    }
  }

  /**
   * Get contract by ID
   */
  async getContract(contractId: string): Promise<any> {
    const { data, error } = await supabase
      .from('contracts')
      .select('*')
      .eq('id', contractId)
      .single();

    if (error) throw error;
    if (!data) throw new Error('Contract not found');

    return data;
  }

  /**
   * Re-analyze a contract (if user wants fresh analysis)
   */
  async reanalyzeContract(contractId: string): Promise<ContractAnalysis> {
    console.log('üîÑ Re-analyzing contract...');
    return this.analyzeContractWithAI(contractId);
  }
}

export const contractService = new ContractService();